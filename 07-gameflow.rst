游戏流程相关的事件
====================

本文将以默认逻辑为基础讲述新月杀的游戏流程与包括翻面、额外阶段/回合在内的相关操作。

何为事件？
-------------

在说到事件之前，我们有必要先说明事件的结构。
诸如id(编号)/data(参数)/room(房间)这类的变量暂且不论，一个事件主要有三个部分：

* \ ``prepare_func``\ 是事件开始时执行的函数（准备函数），这里返回\ ``true``\ 的话就会终止整个事件的运行。

* \ ``main_func``\ 是事件的主函数，涉及该事件大多数时机大多都在这里被触发。

* \ ``clear_func``\ 是事件结束时执行的函数（清理函数），负责事件结束时的收尾（如把处理区）。

* \ ``exit_func``\ 是事件结束后执行的函数（退出函数），负责事件结束后（此时本事件已经不复存在）的后续处理。

几乎所有时机都会在这四个函数中的一个里触发，可以说事件就是整个游戏流程的基础。

这些事件在一个大\ `事件栈`\ 里不断入栈出栈，承担着整个游戏的运行和各种插入结算……

轮次事件（Round）
------------------

新月杀默认逻辑是基于身份局构造出来的，负责正式游戏的action处的代码如下：

.. code-block:: lua

  function GameLogic:action()
    self:trigger(fk.GamePrepared)
    local room = self.room

    execGameEvent(GameEvent.DrawInitial)

    while true do
      execGameEvent(GameEvent.Round)
      if room.game_finished then break end
    end
  end

在执行完分发起始手牌事件后，游戏将一直执行轮次事件直到房间认为游戏结束。

轮次事件有主函数和清理函数两个部分：

2. 主函数：

  1. 在第一轮时，房间会挂上第一轮的标识\ ``FirstRound``\ （在action里的“游戏开始前”（\ ``fk.GamePrepared``\ ）时机里添加），如果下次检测到有这个标识，移除之。

  2. 轮次+1，然后触发时机“轮次开始时”（\ ``fk.RoundStart``\ ）；如果是第一轮，会先额外触发时机“游戏开始时”（\ ``fk.GameStart``\ ）

  3. 从current开始为当前玩家执行回合事件，然后将下家设为当前玩家，直到游戏结束或当前玩家座次比下家高。

  4. 触发时机“轮次结束时”（\ ``fk.RoundEnd``\ ）。

3. 清理函数：

  轮次事件的清理函数非常简单：“清理所有以\ ``-round``\ 结尾的玩家/卡牌标记。”

回合事件（Turn）
----------------

轮次事件会为当前玩家执行回合事件，执行完后将当前玩家更改为下家。

回合事件有准备函数、主函数和清理函数三个部分：

1. 准备函数：

  1. 如果玩家死亡，则跳过；如果玩家背面朝上，翻面，然后跳过。

  2. 触发时机“回合开始前”（\ ``fk.BeforeTurnStart``\ ）然后返回结果。如果返回值为\ ``true``\ ，跳过本回合。

2. 主函数：

  触发时机“回合开始时”（\ ``TurnStart``\ ），然后当前玩家开始依次执行各阶段事件。

  .. note::

    执行阶段事件实际上由\ ``player:play``\ 来完成。
    这其中，当玩家由一个阶段转变为另一个阶段时，会触发时机“阶段开始前”（\ ``EventPhaseChanging``\ ），如果这时候返回\ ``true``\ ，则会阻止这次转变，相当于跳过目标阶段。

3. 清理函数：

  1. 如果本回合被打断，且玩家不处于\ `回合外阶段`\ ，将触发时机“阶段开始前”（\ ``EventPhaseChanging``\ ）切换到\ `回合外阶段`\ ，然后触发时机“阶段开始时”（\ ``EventPhaseStart``\ ），最后清除跳过阶段历史

  2. 触发时机“回合结束时”（\ ``TurnEnd``\ ）和“回合结束后”（\ ``AfterTurnEnd``\ ）

  3. 清理所有基于回合的历史、以\ ``-turn``\ 结尾的玩家/卡牌标记

阶段事件（Phase）
-----------------

默认情况下，玩家会依次经过、\ `准备阶段`\ （Start）、\ `判定阶段`\ （Judge）、\ `摸牌阶段`\ （Draw）、\ `出牌阶段`\ （Play）、\ `弃牌阶段`\ （Discard）、\ `结束阶段`\ （Finish）、\ `回合外阶段`\ （NotActive）。
和前面两个事件不同的是，阶段事件会传入玩家参数，以表示这个阶段的所属者。

.. tip::

  \ `回合外阶段`\ 不是规则集里的阶段，主要用以程序判定。
  如果一个玩家处于\ `回合外阶段`\ ，那么一般表示玩家处于回合外。

阶段事件有主函数、清理函数两个部分：

2. 主函数：

  1. 触发时机“阶段开始时”（\ ``EventPhaseStart``\ ），如果返回true，结束本函数。

  2. 如果玩家不处于\ `回合外阶段`\ ，触发时机“阶段处理时”（\ ``EventPhaseStart``\ ）

  3. 根据玩家所处阶段执行响应函数，包括：

    * 判定阶段：依次将判定区的牌移至处理区开始判定

    * 摸牌阶段：触发时机“摸牌阶段摸牌时”（\ ``DrawNCards``\ ），然后摸牌，然后触发时机“摸牌阶段摸牌后”（\ ``AfterDrawNCards``\ ）

    * 出牌阶段：监听玩家使用牌操作，直到玩家死亡或结束本阶段

    * 弃牌阶段：此处将会判定玩家需要弃置多少牌（不计入手牌上限技能生效），然后根据这个数字弃牌

3. 清理函数：

  1. 如果玩家不处于\ `回合外阶段`\ ，将触发时机“阶段结束时”（\ ``EventPhaseEnd``\ ）和“阶段结束后”（\ ``AfterPhaseEnd``\ ），否则清除跳过阶段历史

  2. 清理所有基于阶段的历史、以\ ``-phase``\ 结尾的玩家/卡牌标记

.. note::

  当你通过\ ``player:gainAnExtraTurn()``\ /\ ``player:gainAnExtraPhase()``\ 获得额外回合/阶段时，
  首先会在本回合/阶段的\ **退出函数**\ 处挂载函数，然后在退出函数处正式引入对应事件，
  同时会为玩家打上“\ `处于额外回合/阶段中`\ ”的tag，该额外事件执行完毕后则取消此tag。

主动技
---------

和特定时机内触发的触发技不同，视为技和主动技是有按钮的技能。

主动技
++++++++

一个主动技有\ **筛选判定**\ （filter）、\ **技能效果**\ （on_effect）两个主要组成部分：

1. 筛选判定：

  当你选择一个主动技时，针对卡牌（card_filter）和目标（target_filter）的筛选判定将会被纳入考量。
  这两个判定的参数都大同小异——\ ``to_select``\ 是待考察的对象（要判断是否可选的卡牌/目标），
  \ ``selected``\ 则是在此之前已选择的对象集合。
  只有令判定返回\ **true**\ 的卡牌/目标才是可以被选中的状态。

  只有当选择的卡牌和目标都满足\ ``card_num``\ /\ ``target_num``\ 等限制条件时，确认按钮才能被按动。

  .. attention::

    在新月杀的选择逻辑中，先选择卡牌，然后才能选择目标。如果已选择目标时再选中卡牌，则会重置对目标的选择。

  .. tip::

    筛选判定的第三个参数（card_filter是targets，而target_filter是cards）代表另一项中已选的对象集合。
    当然，因为选择逻辑中存在先后顺序，所以在使用上仍然存在限制。

2. 技能效果：

  当一个主动技被发动时，系统会进入处理其效果的环节，此时将传入两个参数：

  - \ ``room``\ 是该房间的实例，可以以此使用相关函数。

  - \ ``effect``\ 是一种特殊结构的表——\ ``SkillEffectEvent``\ 。这种表只有3个键：

    * \ ``from``\ ：技能的使用者

    * \ ``tos``\ ：技能选择的目标集合

    * \ ``cards``\ ：技能选择的卡牌集合

  通过用特定键提取\ ``effect``\ 的信息，可以得知选择技能时所选的卡牌和目标，剩下的就自由发挥了……

视为技
++++++++

视为技，是一种“假装自己在选一种牌”的过程。因此，视为技最主要的是\ ``view_as``\ 部分。
同时，视为技和主动技一样，都有\ ``can_use``\ 、\ ``card_num``\ 和\ ``card_filter``\ 判断技能是否可用和能选什么卡牌。

当你确认视为技时，系统将认为你正在选择\ ``view_as``\ 返回的卡牌，因此你能选择什么目标完全由返回的这个卡牌决定。

\ ``view_as``\ 只有一个\ ``cards``\ 参数负责传入已选择的卡牌，
在函数里，一般操作是先用\ ``FK:cloneCard``\ 制造一张虚拟牌，然后通过\ ``addSubcards``\ 将\ ``cards``\ 里的牌纳入子卡，就能达成将\ ``cards``\ 当作目标牌使用或打出的目的。

.. tip::

  一般情况下，视为技拥有\ ``pattern``\ 属性以向系统说明可以视为什么牌。（例如指定无懈可击就可以让系统在问无懈时自动询问你（烧条））
  如果你希望为这个“牌”添加更多条件，那么就需要设置\ ``enable_on_use``\ （负责使用）和\ ``enable_on_response``\ （负责打出）了。
